============================= test session starts ==============================
platform linux -- Python 3.9.2, pytest-6.2.4, py-1.10.0, pluggy-0.13.1
rootdir: /home/ubuntu/shot-glass, configfile: docker/pytest.ini
plugins: forked-1.3.0, cov-2.12.1, xdist-2.3.0, anyio-3.3.0
collected 114 items

python/shot_glass/blender/blender_tools_test.py ......................   [ 19%]
python/shot_glass/hifive/hifive_test.py .......FFFFFFF..F.....FFF....... [ 47%]
..                                                                       [ 49%]
python/shot_glass/hifive/hifive_tools_test.py F.......                   [ 56%]
python/shot_glass/hifive/operator_tools_test.py ....                     [ 59%]
python/shot_glass/hifive/operators_test.py ......F.F                     [ 67%]
python/shot_glass/hifive/type_base_test.py ........                      [ 74%]
python/shot_glass/hifive/validators_test.py ...............              [ 87%]
python/shot_glass/obj/obj_parser_test.py .........                       [ 95%]
python/shot_glass/obj/obj_tools_test.py .F                               [ 97%]
python/shot_glass/plotly/plotly_tools_test.py ...                        [100%]

=================================== FAILURES ===================================
________________________ HiFiveTest.test_geometry_info _________________________

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e59701c0>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e5999820>
engine = None, engine_kwargs = None, args = (), kwargs = {}, relabeling = False
columns = None, cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e59701c0>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e5999820>
args = (), kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e59f1040>
output = {}, idx = 0
obj = 0    0
1    0
2    0
3    0
4    0
5    0
6    0
7    0
Name: f_id, dtype: int64
name = 'f_id'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e5970580>
obj = 0    0
1    0
2    0
3    0
4    0
5    0
6    0
7    0
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e59f1040>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e5970580>
obj = 0    0
1    0
2    0
3    0
4    0
5    0
6    0
7    0
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e59f1040>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   .agg(lambda x: x[a].nunique())[a]\
    .tolist()

python/shot_glass/hifive/hifive_tools.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), key = 'f_id'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), label = 'f_id', takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64'), key = 'f_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_test.HiFiveTest testMethod=test_geometry_info>

    def test_geometry_info(self):
        hi = HiFive()
        hi.data = self.fake_data
>       info = hi.geometry_info

python/shot_glass/hifive/hifive_test.py:445: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive.py:604: in geometry_info
    output.loc['faces_per', 'item'] = self\
python/shot_glass/hifive/hifive.py:672: in __get_unique_counts
    items = hft.get_nunique_a_per_b(
python/shot_glass/hifive/hifive_tools.py:129: in get_nunique_a_per_b
    return data[[a, b]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive_tools.py:132: in <lambda>
    .agg(lambda x: x[a].nunique())[a]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64'), key = 'f_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
____________________ HiFiveTest.test_geometry_info_invalid _____________________

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e439e880>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e43c6dc0>
engine = None, engine_kwargs = None, args = (), kwargs = {}, relabeling = False
columns = None, cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e439e880>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e43c6dc0>
args = (), kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e43c6e50>
output = {}, idx = 0, obj = 0    0
1    0
2    0
3    0
Name: f_id, dtype: int64
name = 'f_id'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e3f5b580>
obj = 0    0
1    0
2    0
3    0
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e43c6e50>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e3f5b580>
obj = 0    0
1    0
2    0
3    0
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e43c6e50>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   .agg(lambda x: x[a].nunique())[a]\
    .tolist()

python/shot_glass/hifive/hifive_tools.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), key = 'f_id'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), label = 'f_id', takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 1, 2, 3], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_test.HiFiveTest testMethod=test_geometry_info_invalid>

    def test_geometry_info_invalid(self):
        hi = HiFive()
        hi.data = self.get_invalid_data()
>       info = hi.geometry_info

python/shot_glass/hifive/hifive_test.py:480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive.py:604: in geometry_info
    output.loc['faces_per', 'item'] = self\
python/shot_glass/hifive/hifive.py:672: in __get_unique_counts
    items = hft.get_nunique_a_per_b(
python/shot_glass/hifive/hifive_tools.py:129: in get_nunique_a_per_b
    return data[[a, b]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive_tools.py:132: in <lambda>
    .agg(lambda x: x[a].nunique())[a]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 1, 2, 3], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
_____________________ HiFiveTest.test_geometry_info_multi ______________________

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e5512970>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e5918d30>
engine = None, engine_kwargs = None, args = (), kwargs = {}, relabeling = False
columns = None, cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e5512970>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e5918d30>
args = (), kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e5999e50>
output = {}, idx = 0
obj = 0    0
1    0
2    0
3    0
0    1
1    1
2    1
3    1
4    1
5    1
6    1
7    1
8    1
9    1
0    2
1    2
2    2
3    2
4    2
5    2
Name: f_id, dtype: int64
name = 'f_id'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e5516940>
obj = 0    0
1    0
2    0
3    0
0    1
1    1
2    1
3    1
4    1
5    1
6    1
7    1
8    1
9    1
0    2
1    2
2    2
3    2
4    2
5    2
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e5999e50>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e5516940>
obj = 0    0
1    0
2    0
3    0
0    1
1    1
2    1
3    1
4    1
5    1
6    1
7    1
8    1
9    1
0    2
1    2
2    2
3    2
4    2
5    2
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e5999e50>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   .agg(lambda x: x[a].nunique())[a]\
    .tolist()

python/shot_glass/hifive/hifive_tools.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), key = 'f_id'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), label = 'f_id', takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5], dtype='int64')
key = 'f_id', method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_test.HiFiveTest testMethod=test_geometry_info_multi>

    def test_geometry_info_multi(self):
        hi = HiFive()
        hi.data = self.get_multi_data()
>       info = hi.geometry_info

python/shot_glass/hifive/hifive_test.py:512: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive.py:604: in geometry_info
    output.loc['faces_per', 'item'] = self\
python/shot_glass/hifive/hifive.py:672: in __get_unique_counts
    items = hft.get_nunique_a_per_b(
python/shot_glass/hifive/hifive_tools.py:129: in get_nunique_a_per_b
    return data[[a, b]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive_tools.py:132: in <lambda>
    .agg(lambda x: x[a].nunique())[a]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5], dtype='int64')
key = 'f_id', method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
______________________ HiFiveTest.test_geometry_info_ngon ______________________

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e5547970>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e43d2ca0>
engine = None, engine_kwargs = None, args = (), kwargs = {}, relabeling = False
columns = None, cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e5547970>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e43d2ca0>
args = (), kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e43d2dc0>
output = {}, idx = 0
obj = 0    0
1    0
2    0
3    0
4    0
5    0
6    0
7    0
8    0
9    0
Name: f_id, dtype: int64
name = 'f_id'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e57d0b20>
obj = 0    0
1    0
2    0
3    0
4    0
5    0
6    0
7    0
8    0
9    0
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e43d2dc0>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e57d0b20>
obj = 0    0
1    0
2    0
3    0
4    0
5    0
6    0
7    0
8    0
9    0
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e43d2dc0>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   .agg(lambda x: x[a].nunique())[a]\
    .tolist()

python/shot_glass/hifive/hifive_tools.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), key = 'f_id'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), label = 'f_id', takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype='int64'), key = 'f_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_test.HiFiveTest testMethod=test_geometry_info_ngon>

    def test_geometry_info_ngon(self):
        hi = HiFive()
        hi.data = self.get_ngon_data()
>       info = hi.geometry_info

python/shot_glass/hifive/hifive_test.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive.py:604: in geometry_info
    output.loc['faces_per', 'item'] = self\
python/shot_glass/hifive/hifive.py:672: in __get_unique_counts
    items = hft.get_nunique_a_per_b(
python/shot_glass/hifive/hifive_tools.py:129: in get_nunique_a_per_b
    return data[[a, b]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive_tools.py:132: in <lambda>
    .agg(lambda x: x[a].nunique())[a]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype='int64'), key = 'f_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
_______________ HiFiveTest.test_geometry_info_no_edges_no_faces ________________

self = Int64Index([], dtype='int64'), key = 'v_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'v_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e5734be0>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e4401790>
engine = None, engine_kwargs = None, args = (), kwargs = {}, relabeling = False
columns = None, cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e5734be0>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e4401790>
args = (), kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e4401700>
output = {}, idx = 0
obj = 0    0
1    1
2    1
3    2
4    2
5    3
6    3
7    0
Name: v_id, dtype: int64
name = 'v_id'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e5734520>
obj = 0    0
1    1
2    1
3    2
4    2
5    3
6    3
7    0
Name: v_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e4401700>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e5734520>
obj = 0    0
1    1
2    1
3    2
4    2
5    3
6    3
7    0
Name: v_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e4401700>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: v_id, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: v_id, dtype: int64)

>   .agg(lambda x: x[a].nunique())[a]\
    .tolist()

python/shot_glass/hifive/hifive_tools.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: v_id, dtype: int64), key = 'v_id'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: v_id, dtype: int64), label = 'v_id', takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'v_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'v_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64'), key = 'v_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'v_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_test.HiFiveTest testMethod=test_geometry_info_no_edges_no_faces>

    def test_geometry_info_no_edges_no_faces(self):
        hi = HiFive()
        hi.data = self.fake_data
        hi.data['e_id'] = np.nan
        hi.data['f_id'] = np.nan
    
>       info = hi.geometry_info

python/shot_glass/hifive/hifive_test.py:523: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive.py:608: in geometry_info
    output.loc['vertices_per', 'item'] = self\
python/shot_glass/hifive/hifive.py:672: in __get_unique_counts
    items = hft.get_nunique_a_per_b(
python/shot_glass/hifive/hifive_tools.py:129: in get_nunique_a_per_b
    return data[[a, b]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive_tools.py:132: in <lambda>
    .agg(lambda x: x[a].nunique())[a]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64'), key = 'v_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'v_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
_________________ HiFiveTest.test_geometry_info_quadrilateral __________________

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e551a3a0>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e43d2a60>
engine = None, engine_kwargs = None, args = (), kwargs = {}, relabeling = False
columns = None, cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e551a3a0>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e43d2a60>
args = (), kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e43d2af0>
output = {}, idx = 0
obj = 0    0
1    0
2    0
3    0
4    0
5    0
6    0
7    0
Name: f_id, dtype: int64
name = 'f_id'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e3ede970>
obj = 0    0
1    0
2    0
3    0
4    0
5    0
6    0
7    0
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e43d2af0>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e3ede970>
obj = 0    0
1    0
2    0
3    0
4    0
5    0
6    0
7    0
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e43d2af0>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   .agg(lambda x: x[a].nunique())[a]\
    .tolist()

python/shot_glass/hifive/hifive_tools.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), key = 'f_id'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), label = 'f_id', takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64'), key = 'f_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_test.HiFiveTest testMethod=test_geometry_info_quadrilateral>

    def test_geometry_info_quadrilateral(self):
        hi = HiFive()
        hi.data = self.get_quadrilateral_data()
>       info = hi.geometry_info

python/shot_glass/hifive/hifive_test.py:496: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive.py:604: in geometry_info
    output.loc['faces_per', 'item'] = self\
python/shot_glass/hifive/hifive.py:672: in __get_unique_counts
    items = hft.get_nunique_a_per_b(
python/shot_glass/hifive/hifive_tools.py:129: in get_nunique_a_per_b
    return data[[a, b]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive_tools.py:132: in <lambda>
    .agg(lambda x: x[a].nunique())[a]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64'), key = 'f_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
____________________ HiFiveTest.test_geometry_info_triangle ____________________

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e55208b0>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e59f11f0>
engine = None, engine_kwargs = None, args = (), kwargs = {}, relabeling = False
columns = None, cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e55208b0>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e59f11f0>
args = (), kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e5436550>
output = {}, idx = 0
obj = 0    0
1    0
2    0
3    0
4    0
5    0
Name: f_id, dtype: int64
name = 'f_id'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e41b1820>
obj = 0    0
1    0
2    0
3    0
4    0
5    0
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e5436550>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e41b1820>
obj = 0    0
1    0
2    0
3    0
4    0
5    0
Name: f_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e5436550>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_id, dtype: int64)

>   .agg(lambda x: x[a].nunique())[a]\
    .tolist()

python/shot_glass/hifive/hifive_tools.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), key = 'f_id'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_id, dtype: int64), label = 'f_id', takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'f_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 1, 2, 3, 4, 5], dtype='int64'), key = 'f_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_test.HiFiveTest testMethod=test_geometry_info_triangle>

    def test_geometry_info_triangle(self):
        hi = HiFive()
        hi.data = self.get_triangle_data()
>       info = hi.geometry_info

python/shot_glass/hifive/hifive_test.py:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive.py:604: in geometry_info
    output.loc['faces_per', 'item'] = self\
python/shot_glass/hifive/hifive.py:672: in __get_unique_counts
    items = hft.get_nunique_a_per_b(
python/shot_glass/hifive/hifive_tools.py:129: in get_nunique_a_per_b
    return data[[a, b]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive_tools.py:132: in <lambda>
    .agg(lambda x: x[a].nunique())[a]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 1, 2, 3, 4, 5], dtype='int64'), key = 'f_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
______________________ HiFiveTest.test_get_unique_counts _______________________

self = Int64Index([], dtype='int64'), key = 'e_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'e_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e58d2100>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e4401dc0>
engine = None, engine_kwargs = None, args = (), kwargs = {}, relabeling = False
columns = None, cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e58d2100>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e4401dc0>
args = (), kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e4401ee0>
output = {}, idx = 0
obj = 0    0
1    0
2    1
3    1
4    2
5    2
6    3
7    3
7    4
Name: e_id, dtype: int64
name = 'e_id'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e3e679a0>
obj = 0    0
1    0
2    1
3    1
4    2
5    2
6    3
7    3
7    4
Name: e_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e4401ee0>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e3e679a0>
obj = 0    0
1    0
2    1
3    1
4    2
5    2
6    3
7    3
7    4
Name: e_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e4401ee0>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: e_id, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: e_id, dtype: int64)

>   .agg(lambda x: x[a].nunique())[a]\
    .tolist()

python/shot_glass/hifive/hifive_tools.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: e_id, dtype: int64), key = 'e_id'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: e_id, dtype: int64), label = 'e_id', takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'e_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'e_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64'), key = 'e_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'e_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_test.HiFiveTest testMethod=test_get_unique_counts>

    def test_get_unique_counts(self):
        hi = HiFive()
        hi.data = self.fake_data
        row = hi.data.tail(1).copy()
        row.v_id = 9
        row.e_id = 4
        row.f_id = 1
        hi.data = hi.data.append(row)
    
>       result = hi._HiFive__get_unique_counts('e_id', 'f_id')

python/shot_glass/hifive/hifive_test.py:565: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive.py:672: in __get_unique_counts
    items = hft.get_nunique_a_per_b(
python/shot_glass/hifive/hifive_tools.py:129: in get_nunique_a_per_b
    return data[[a, b]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive_tools.py:132: in <lambda>
    .agg(lambda x: x[a].nunique())[a]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64'), key = 'e_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'e_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
_______________________ HiFiveTest.test_map_many_to_one ________________________

self = Int64Index([], dtype='int64'), key = 'v_i_bar', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'v_i_bar'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e3fe2220>
func = <function HiFive.map.<locals>.<lambda> at 0x7fa9e58e2ee0>, engine = None
engine_kwargs = None, args = (), kwargs = {}, relabeling = False, columns = None
cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e3fe2220>
func = <function HiFive.map.<locals>.<lambda> at 0x7fa9e58e2ee0>, args = ()
kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e58e2f70>
output = {}, idx = 0
obj = 0    0
1    1
2    1
3    2
4    2
5    3
6    3
7    0
Name: v_i_bar, dtype: int64
name = 'v_i_bar'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e5808ca0>
obj = 0    0
1    1
2    1
3    2
4    2
5    3
6    3
7    0
Name: v_i_bar, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e58e2f70>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e5808ca0>
obj = 0    0
7    0
1    1
2    1
3    2
4    2
5    3
6    3
Name: v_i_bar, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e58e2f70>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: v_i_bar, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: v_i_bar, dtype: int64)

>   .agg(lambda x: aggregator(x[source]))

python/shot_glass/hifive/hifive.py:408: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: v_i_bar, dtype: int64), key = 'v_i_bar'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: v_i_bar, dtype: int64), label = 'v_i_bar'
takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'v_i_bar', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'v_i_bar'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 7], dtype='int64'), key = 'v_i_bar', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'v_i_bar'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_test.HiFiveTest testMethod=test_map_many_to_one>

    def test_map_many_to_one(self):
        hi = HiFive()
        hi.data = self.get_quadrilateral_data()
    
        hi.data['v_i_bar'] = hi.data.v_id
>       hi.map('v_i_bar', 'v_f_foo', lambda x: x.mean())

python/shot_glass/hifive/hifive_test.py:299: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive.py:406: in map
    lut = self.data[[id_col, source]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive.py:408: in <lambda>
    .agg(lambda x: aggregator(x[source]))
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 7], dtype='int64'), key = 'v_i_bar', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'v_i_bar'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
_______________________ HiFiveTest.test_map_one_to_many ________________________

self = Int64Index([], dtype='int64'), key = 'f_i_foo', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_i_foo'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e43ac550>
func = <function HiFive.map.<locals>.<lambda> at 0x7fa9e43c6ee0>, engine = None
engine_kwargs = None, args = (), kwargs = {}, relabeling = False, columns = None
cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e43ac550>
func = <function HiFive.map.<locals>.<lambda> at 0x7fa9e43c6ee0>, args = ()
kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e442ff70>
output = {}, idx = 0
obj = 0    0
1    1
2    1
3    2
4    2
5    3
6    3
7    0
Name: f_i_foo, dtype: int64
name = 'f_i_foo'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e43ac6a0>
obj = 0    0
1    1
2    1
3    2
4    2
5    3
6    3
7    0
Name: f_i_foo, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e442ff70>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e43ac6a0>
obj = 0    0
1    1
2    1
3    2
4    2
5    3
6    3
7    0
Name: f_i_foo, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e442ff70>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_i_foo, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: f_i_foo, dtype: int64)

>   .agg(lambda x: aggregator(x[source]))

python/shot_glass/hifive/hifive.py:408: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_i_foo, dtype: int64), key = 'f_i_foo'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: f_i_foo, dtype: int64), label = 'f_i_foo'
takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'f_i_foo', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_i_foo'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64'), key = 'f_i_foo'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'f_i_foo'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_test.HiFiveTest testMethod=test_map_one_to_many>

    def test_map_one_to_many(self):
        hi = HiFive()
        hi.data = self.get_quadrilateral_data()
    
        hi.data['f_i_foo'] = hi.data.v_id
>       hi.map('f_i_foo', 'v_f_bar', lambda x: x.mean())

python/shot_glass/hifive/hifive_test.py:288: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive.py:406: in map
    lut = self.data[[id_col, source]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive.py:408: in <lambda>
    .agg(lambda x: aggregator(x[source]))
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 1, 2, 3, 4, 5, 6, 7], dtype='int64'), key = 'f_i_foo'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'f_i_foo'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
________________________ HiFiveTest.test_map_one_to_one ________________________

self = Int64Index([], dtype='int64'), key = '__temp', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: '__temp'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e3d622e0>
func = <function HiFive.map.<locals>.<lambda> at 0x7fa9e5416940>, engine = None
engine_kwargs = None, args = (), kwargs = {}, relabeling = False, columns = None
cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e3d622e0>
func = <function HiFive.map.<locals>.<lambda> at 0x7fa9e5416940>, args = ()
kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e5416af0>
output = {}, idx = 0
obj = 0    0
1    1
2    1
3    2
4    2
5    3
6    3
7    0
Name: __temp, dtype: int64
name = '__temp'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e3d62dc0>
obj = 0    0
1    1
2    1
3    2
4    2
5    3
6    3
7    0
Name: __temp, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e5416af0>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e3d62dc0>
obj = 0    0
7    0
1    1
2    1
3    2
4    2
5    3
6    3
Name: __temp, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e5416af0>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: __temp, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: __temp, dtype: int64)

>   .agg(lambda x: aggregator(x[source]))

python/shot_glass/hifive/hifive.py:408: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: __temp, dtype: int64), key = '__temp'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: __temp, dtype: int64), label = '__temp'
takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = '__temp', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: '__temp'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 7], dtype='int64'), key = '__temp', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: '__temp'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_test.HiFiveTest testMethod=test_map_one_to_one>

    def test_map_one_to_one(self):
        hi = HiFive()
        hi.data = self.get_quadrilateral_data()
    
>       hi.map('v_id', 'v_i_foo', lambda x: 27)

python/shot_glass/hifive/hifive_test.py:268: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive.py:406: in map
    lut = self.data[[id_col, source]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive.py:408: in <lambda>
    .agg(lambda x: aggregator(x[source]))
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 7], dtype='int64'), key = '__temp', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: '__temp'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
__________________ HiFiveToolsTests.test_get_nunique_a_per_b ___________________

self = Int64Index([], dtype='int64'), key = 'a', method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'a'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e55aac70>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e5416e50>
engine = None, engine_kwargs = None, args = (), kwargs = {}, relabeling = False
columns = None, cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e55aac70>
func = <function get_nunique_a_per_b.<locals>.<lambda> at 0x7fa9e5416e50>
args = (), kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e54169d0>
output = {}, idx = 0, obj = 0    q
1    q
2    x
3    y
Name: a, dtype: object
name = 'a'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e5a3a670>
obj = 0    q
1    q
2    x
3    y
Name: a, dtype: object
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e54169d0>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e5a3a670>
obj = 0    q
1    q
2    x
3    y
Name: a, dtype: object
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e54169d0>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: a, dtype: object)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: a, dtype: object)

>   .agg(lambda x: x[a].nunique())[a]\
    .tolist()

python/shot_glass/hifive/hifive_tools.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: a, dtype: object), key = 'a'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: a, dtype: object), label = 'a', takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'a', method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'a'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([0, 1], dtype='int64'), key = 'a', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'a'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.hifive_tools_test.HiFiveToolsTests testMethod=test_get_nunique_a_per_b>

    def test_get_nunique_a_per_b(self):
        data = DataFrame()
        data['a'] = ['q', 'q', 'x', 'y']
        data['b'] = [0, 0, 1, 1]
    
>       result = hft.get_nunique_a_per_b(data, 'a', 'b')

python/shot_glass/hifive/hifive_tools_test.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
python/shot_glass/hifive/hifive_tools.py:129: in get_nunique_a_per_b
    return data[[a, b]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive_tools.py:132: in <lambda>
    .agg(lambda x: x[a].nunique())[a]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([0, 1], dtype='int64'), key = 'a', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'a'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
__________________ HiFiveOperatorsTests.test_to_plotly_figure __________________

self = Int64Index([], dtype='int64'), key = 'v_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'v_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e442bf70>
func = <function HiFive.map.<locals>.<lambda> at 0x7fa9e419bd30>, engine = None
engine_kwargs = None, args = (), kwargs = {}, relabeling = False, columns = None
cyfunc = None

    @doc(_agg_template, examples=_agg_examples_doc, klass="Series")
    def aggregate(self, func=None, *args, engine=None, engine_kwargs=None, **kwargs):
    
        if maybe_use_numba(engine):
            with group_selection_context(self):
                data = self._selected_obj
            result, index = self._aggregate_with_numba(
                data.to_frame(), func, *args, engine_kwargs=engine_kwargs, **kwargs
            )
            return self.obj._constructor(result.ravel(), index=index, name=data.name)
    
        relabeling = func is None
        columns = None
        if relabeling:
            columns, func = validate_func_kwargs(kwargs)
            kwargs = {}
    
        if isinstance(func, str):
            return getattr(self, func)(*args, **kwargs)
    
        elif isinstance(func, abc.Iterable):
            # Catch instances of lists / tuples
            # but not the class list / tuple itself.
            func = maybe_mangle_lambdas(func)
            ret = self._aggregate_multiple_funcs(func)
            if relabeling:
                # error: Incompatible types in assignment (expression has type
                # "Optional[List[str]]", variable has type "Index")
                ret.columns = columns  # type: ignore[assignment]
            return ret
    
        else:
            cyfunc = com.get_cython_func(func)
            if cyfunc and not args and not kwargs:
                return getattr(self, cyfunc)()
    
            if self.grouper.nkeys > 1:
                return self._python_agg_general(func, *args, **kwargs)
    
            try:
>               return self._python_agg_general(func, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.generic.SeriesGroupBy object at 0x7fa9e442bf70>
func = <function HiFive.map.<locals>.<lambda> at 0x7fa9e419bd30>, args = ()
kwargs = {}
f = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e419be50>
output = {}, idx = 0
obj = 1     1
3     1
6     1
0     3
4     3
7     3
2     0
5     0
10    1
11    1
14    1
8     2
12    2
9     3
13    3
15    3
Name: v_id, dtype: int64
name = 'v_id'

    @final
    def _python_agg_general(self, func, *args, **kwargs):
        func = com.is_builtin_func(func)
        f = lambda x: func(x, *args, **kwargs)
    
        # iterate through "columns" ex exclusions to populate output dict
        output: dict[base.OutputKey, ArrayLike] = {}
    
        if self.ngroups == 0:
            # agg_series below assumes ngroups > 0
            return self._python_apply_general(f, self._selected_obj)
    
        for idx, obj in enumerate(self._iterate_slices()):
            name = obj.name
    
            try:
                # if this function is invalid for this dtype, we will ignore it.
>               result = self.grouper.agg_series(obj, f)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e442b940>
obj = 1     1
3     1
6     1
0     3
4     3
7     3
2     0
5     0
10    1
11    1
14    1
8     2
12    2
9     3
13    3
15    3
Name: v_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e419be50>
preserve_dtype = False

    @final
    def agg_series(
        self, obj: Series, func: F, preserve_dtype: bool = False
    ) -> ArrayLike:
        """
        Parameters
        ----------
        obj : Series
        func : function taking a Series and returning a scalar-like
        preserve_dtype : bool
            Whether the aggregation is known to be dtype-preserving.
    
        Returns
        -------
        np.ndarray or ExtensionArray
        """
        # test_groupby_empty_with_category gets here with self.ngroups == 0
        #  and len(obj) > 0
    
        if len(obj) == 0:
            # SeriesGrouper would raise if we were to call _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        elif not isinstance(obj._values, np.ndarray):
            # _aggregate_series_fast would raise TypeError when
            #  calling libreduction.Slider
            # In the datetime64tz case it would incorrectly cast to tz-naive
            # TODO: can we get a performant workaround for EAs backed by ndarray?
            result = self._aggregate_series_pure_python(obj, func)
    
            # we can preserve a little bit more aggressively with EA dtype
            #  because maybe_cast_pointwise_result will do a try/except
            #  with _from_sequence.  NB we are assuming here that _from_sequence
            #  is sufficiently strict that it casts appropriately.
            preserve_dtype = True
    
        elif obj.index._has_complex_internals:
            # Preempt TypeError in _aggregate_series_fast
            result = self._aggregate_series_pure_python(obj, func)
    
        else:
>           result = self._aggregate_series_fast(obj, func)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pandas.core.groupby.ops.BaseGrouper object at 0x7fa9e442b940>
obj = 1     1
3     1
6     1
0     3
4     3
7     3
2     0
5     0
10    1
11    1
14    1
8     2
12    2
9     3
13    3
15    3
Name: v_id, dtype: int64
func = <function GroupBy._python_agg_general.<locals>.<lambda> at 0x7fa9e419be50>

    def _aggregate_series_fast(self, obj: Series, func: F) -> np.ndarray:
        # -> np.ndarray[object]
    
        # At this point we have already checked that
        #  - obj.index is not a MultiIndex
        #  - obj is backed by an ndarray, not ExtensionArray
        #  - len(obj) > 0
        func = com.is_builtin_func(func)
    
        ids, _, ngroups = self.group_info
    
        # avoids object / Series creation overhead
        indexer = get_group_index_sorter(ids, ngroups)
        obj = obj.take(indexer)
        ids = ids.take(indexer)
        sgrouper = libreduction.SeriesGrouper(obj, func, ids, ngroups)
>       result, _ = sgrouper.get_result()

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:281: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/reduction.pyx:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: v_id, dtype: int64)

>   f = lambda x: func(x, *args, **kwargs)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = Series([], Name: v_id, dtype: int64)

>   .agg(lambda x: aggregator(x[source]))

python/shot_glass/hifive/hifive.py:408: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: v_id, dtype: int64), key = 'v_id'

    def __getitem__(self, key):
        key = com.apply_if_callable(key, self)
    
        if key is Ellipsis:
            return self
    
        key_is_scalar = is_scalar(key)
        if isinstance(key, (list, tuple)):
            key = unpack_1tuple(key)
    
        if is_integer(key) and self.index._should_fallback_to_positional():
            return self._values[key]
    
        elif key_is_scalar:
>           return self._get_value(key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: v_id, dtype: int64), label = 'v_id', takeable = False

    def _get_value(self, label, takeable: bool = False):
        """
        Quickly retrieve single value at passed index label.
    
        Parameters
        ----------
        label : object
        takeable : interpret the index as indexers, default False
    
        Returns
        -------
        scalar value
        """
        if takeable:
            return self._values[label]
    
        # Similar to Index.get_value, but we do not fall back to positional
>       loc = self.index.get_loc(label)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([], dtype='int64'), key = 'v_id', method = None
tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'v_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError

During handling of the above exception, another exception occurred:

self = Int64Index([1, 3, 6, 0, 4, 7, 2, 5], dtype='int64'), key = 'v_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3361: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index.pyx:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???

pandas/_libs/index_class_helper.pxi:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'v_id'

pandas/_libs/index_class_helper.pxi:105: KeyError

The above exception was the direct cause of the following exception:

self = <shot_glass.hifive.operators_test.HiFiveOperatorsTests testMethod=test_to_plotly_figure>

    def test_to_plotly_figure(self):
        source = lbt.relative_path(__file__, '../../../resources/face.obj')
        data = operators.read_obj(fullpath=source)
>       result = operators.to_plotly_figure(data=data)

python/shot_glass/hifive/operators_test.py:107: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../blender/2.93/python/lib/python3.9/site-packages/wrapt/wrappers.py:566: in __call__
    return self._self_wrapper(self.__wrapped__, self._self_instance,
python/shot_glass/hifive/operator_tools.py:96: in wrapper
    return wrapped(**params)
python/shot_glass/hifive/operators.py:127: in to_plotly_figure
    hi = hi.map(
python/shot_glass/hifive/hifive.py:406: in map
    lut = self.data[[id_col, source]]\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:269: in aggregate
    result = self._aggregate_named(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:492: in _aggregate_named
    output = func(group, *args, **kwargs)
python/shot_glass/hifive/hifive.py:408: in <lambda>
    .agg(lambda x: aggregator(x[source]))
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:942: in __getitem__
    return self._get_value(key)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/series.py:1051: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Int64Index([1, 3, 6, 0, 4, 7, 2, 5], dtype='int64'), key = 'v_id'
method = None, tolerance = None

    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
    
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
E               KeyError: 'v_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexes/base.py:3363: KeyError
----------------------------- Captured stdout call -----------------------------
Info: Deleted 1 object(s)
Info: Deleted 1 object(s)
[Vector((0.0, 0.0, 0.0)), Vector((1.0, 0.0, 0.0)), Vector((1.0, 1.0, 0.0)), Vector((0.0, 1.0, 0.0))]
[[0, 1], [0, 3], [1, 2], [2, 3]]
[[0, 1, 2, 3]]
_____________________ HiFiveOperatorsTests.test_write_obj ______________________

self = <shot_glass.hifive.operators_test.HiFiveOperatorsTests testMethod=test_write_obj>

    def test_write_obj(self):
        source = lbt.relative_path(__file__, '../../../resources/face.obj')
        data = operators.read_obj(fullpath=source)
        with TemporaryDirectory() as root:
            target = os.path.join(root, 'foo.obj')
>           operators.write_obj(data=data, fullpath=target, validate='all')

python/shot_glass/hifive/operators_test.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../blender/2.93/python/lib/python3.9/site-packages/wrapt/wrappers.py:566: in __call__
    return self._self_wrapper(self.__wrapped__, self._self_instance,
python/shot_glass/hifive/operator_tools.py:96: in wrapper
    return wrapped(**params)
python/shot_glass/hifive/operators.py:285: in write_obj
    faces = data\
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: in aggregate
    return self._python_agg_general(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: in _python_agg_general
    result = self.grouper.agg_series(obj, f)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: in agg_series
    result = self._aggregate_series_fast(obj, func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: in _aggregate_series_fast
    result, _ = sgrouper.get_result()
pandas/_libs/reduction.pyx:281: in pandas._libs.reduction.SeriesGrouper.get_result
    ???
pandas/_libs/reduction.pyx:88: in pandas._libs.reduction._BaseGrouper._apply_to_group
    ???
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: in <lambda>
    f = lambda x: func(x, *args, **kwargs)
python/shot_glass/obj/obj_tools.py:69: in row_to_obj_face
    data = row.v_id
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: i_id, dtype: int64), name = 'v_id'

    def __getattr__(self, name: str):
        """
        After regular attribute access, try looking up the name
        This allows simpler access to columns for interactive use.
        """
        # Note: obj.x will always call obj.__getattribute__('x') prior to
        # calling obj.__getattr__('x').
        if (
            name not in self._internal_names_set
            and name not in self._metadata
            and name not in self._accessors
            and self._info_axis._can_hold_identifiers_and_holds_name(name)
        ):
            return self[name]
>       return object.__getattribute__(self, name)
E       AttributeError: 'Series' object has no attribute 'v_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/generic.py:5478: AttributeError
__________________ HiFiveValidatorsTests.test_row_to_obj_face __________________

self = <shot_glass.obj.obj_tools_test.HiFiveValidatorsTests testMethod=test_row_to_obj_face>

    def test_row_to_obj_face(self):
        data = HiFiveTestBase().get_quadrilateral_data()
>       result = data.groupby('f_id')\
            .agg(objt.row_to_obj_face).v_id.tolist()

python/shot_glass/obj/obj_tools_test.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:1010: in aggregate
    result = gba.agg()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:164: in agg
    return self.agg_list_like()
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/apply.py:355: in agg_list_like
    new_res = colg.aggregate(arg)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:249: in aggregate
    ret = self._aggregate_multiple_funcs(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:303: in _aggregate_multiple_funcs
    results[key] = self.aggregate(func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/generic.py:265: in aggregate
    return self._python_agg_general(func, *args, **kwargs)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1310: in _python_agg_general
    result = self.grouper.agg_series(obj, f)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1028: in agg_series
    result = self._aggregate_series_fast(obj, func)
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/ops.py:1053: in _aggregate_series_fast
    result, _ = sgrouper.get_result()
pandas/_libs/reduction.pyx:281: in pandas._libs.reduction.SeriesGrouper.get_result
    ???
pandas/_libs/reduction.pyx:88: in pandas._libs.reduction._BaseGrouper._apply_to_group
    ???
../blender/2.93/python/lib/python3.9/site-packages/pandas/core/groupby/groupby.py:1296: in <lambda>
    f = lambda x: func(x, *args, **kwargs)
python/shot_glass/obj/obj_tools.py:69: in row_to_obj_face
    data = row.v_id
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Series([], Name: i_id, dtype: int64), name = 'v_id'

    def __getattr__(self, name: str):
        """
        After regular attribute access, try looking up the name
        This allows simpler access to columns for interactive use.
        """
        # Note: obj.x will always call obj.__getattribute__('x') prior to
        # calling obj.__getattr__('x').
        if (
            name not in self._internal_names_set
            and name not in self._metadata
            and name not in self._accessors
            and self._info_axis._can_hold_identifiers_and_holds_name(name)
        ):
            return self[name]
>       return object.__getattribute__(self, name)
E       AttributeError: 'Series' object has no attribute 'v_id'

../blender/2.93/python/lib/python3.9/site-packages/pandas/core/generic.py:5478: AttributeError
=============================== warnings summary ===============================
python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_map_has_nans
  /home/ubuntu/blender/2.93/python/lib/python3.9/site-packages/pandas/core/indexing.py:719: FutureWarning: Slicing a positional slice with .loc is not supported, and will raise TypeError in a future version.  Use .loc with labels or .iloc with positions instead.
    indexer = self._get_setitem_indexer(key)

python/shot_glass/hifive/operators_test.py::HiFiveOperatorsTests::test_from_blender_scene
python/shot_glass/hifive/operators_test.py::HiFiveOperatorsTests::test_read_obj
python/shot_glass/hifive/operators_test.py::HiFiveOperatorsTests::test_to_blender_scene
python/shot_glass/hifive/operators_test.py::HiFiveOperatorsTests::test_to_plotly_figure
python/shot_glass/hifive/operators_test.py::HiFiveOperatorsTests::test_write_obj
  /home/ubuntu/blender/2.93/python/lib/python3.9/site-packages/pandas/core/generic.py:5507: SettingWithCopyWarning: 
  A value is trying to be set on a copy of a slice from a DataFrame.
  Try using .loc[row_indexer,col_indexer] = value instead
  
  See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
    self[name] = value

-- Docs: https://docs.pytest.org/en/stable/warnings.html
=========================== short test summary info ============================
FAILED python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_geometry_info
FAILED python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_geometry_info_invalid
FAILED python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_geometry_info_multi
FAILED python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_geometry_info_ngon
FAILED python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_geometry_info_no_edges_no_faces
FAILED python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_geometry_info_quadrilateral
FAILED python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_geometry_info_triangle
FAILED python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_get_unique_counts
FAILED python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_map_many_to_one
FAILED python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_map_one_to_many
FAILED python/shot_glass/hifive/hifive_test.py::HiFiveTest::test_map_one_to_one
FAILED python/shot_glass/hifive/hifive_tools_test.py::HiFiveToolsTests::test_get_nunique_a_per_b
FAILED python/shot_glass/hifive/operators_test.py::HiFiveOperatorsTests::test_to_plotly_figure
FAILED python/shot_glass/hifive/operators_test.py::HiFiveOperatorsTests::test_write_obj
FAILED python/shot_glass/obj/obj_tools_test.py::HiFiveValidatorsTests::test_row_to_obj_face
================== 15 failed, 99 passed, 6 warnings in 41.86s ==================
